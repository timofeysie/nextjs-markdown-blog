---
title: "React TDD Anagram example"
date: "2020-08-09 (updated 2022-11-08)"
og:
  description: "A detailed walk through of TDD using React with TypeScript to solve a simple anagram coding challenge"
  image: "https://timothycurchod.com/og/Capture-react-tdd.png"
author:
  twitter: "timofey"
  name: "Timothy Curchod"
---

## TL;DR

- This article talks about using the red-green-refactor method to practice test-driven development.
- It uses a real world example using React with Typescript is shown using an anagram generator challenge.

To lean more about TDD with the red-green-refactor method in a group setting, [see my previous article on the subject](https://timothycurchod.com/writings/red-green-refactor-repeat-dojo).

## React TDD Anagram example

One of the most basic coding challenges is the anagram generator.

Inspired by the [Cyber-dojo site](https://cyber-dojo.org/), the task looks like this:

Write a program to generate all potential anagrams of an input string.

For example, the potential anagrams of "biro" are

```txt
biro bior brio broi boir bori
ibro ibor irbo irob iobr iorb
rbio rboi ribo riob roib robi
obir obri oibr oirb orbi orib
```

### Setup the example

First create a blank starter using TypeScript and install the [React Testing Library](https://testing-library.com/docs/react-testing-library/intro):

```bash
npx create-react-app tdd-react --template typescript
npm install @testing-library/react
```

### Jest & the testing library

This article will use Jest with the React Testing Library.  Jest lets you access the DOM and mocking functions and the React Testing Library provides tools to test and render hooks without getting into implementation details.

Next, it's a good idea to make sure everything is working.  Also, you might want to open another terminal and run the example unit test to make sure that's working also.  You can always switch between testing and running the app.  We will mainly focus on the testing for this article.  Here are the two commands:

```bash
npm run
npm test
```

Open the App.tsx file and replace the contents with this:

#### **`src/App.tsx`**

```js
import React from "react";
import "./App.css";
import { useAnagrams } from "./useAnagrams";

function App() {
  const [displayOutput, setDisplayMessage] = React.useState(false);
  const [input, setOutput] = React.useState("");
  const [anagram, updateAnagram] = useAnagrams("");

  const update = () => {
    updateAnagram(input);
    setDisplayMessage(true);
  }

  return (
    <div className="App">
      <label htmlFor="name" className="item padding">
        Enter text
      </label>
      <input
        id="name"
        type="text"
        className="padding"
        onChange={(event) => setOutput(event.currentTarget.value)}
      />
      <button onClick={() => update()} className="padding">
        Submit
      </button>
      {displayOutput && <p className="item">{anagram}</p>}
    </div>
  );
}
export default App;
```

This app now has an input, that when the submit button is pressed, will output the contents of the input.  We are using React hooks to create two values, and functions to set them:

```js
  const [displayOutput, setDisplayMessage] = React.useState(false);
  const [input, setOutput] = React.useState("");
  const [anagram, updateAnagram] = useAnagrams("");
```

We could import useState from React and use it without the dot notation there, but we can do that later when refactoring.  We could also use a better method for getting the input instead of setting it in the input onChange event.  For now we have something that will let the user enter the text they want to generate anagrams for.

Then, we have a custom hook: useAnagrams.  This file will need to be created also:

#### **`src/useAnagrams.ts` initial**

```ts
import { useState } from "react";

export function useAnagrams(input: any) {
const [anagram, setState] = useState(input);

  const updateAnagram = (input: string) => {
    const newVal = input; // <-- custom anagram logic will go here
    setState(newVal);
  }
  return [anagram, updateAnagram ];
}
```

The first version of this tutorial used only the App.tsx file to create the anagram logic, and it was tested by looking at the DOM created by that.  One point of this game is to keep things simple and focus on the TDD aspects of this game.  Therefore it seemed like a better idea to create a custom hook and just test that functionality, instead of involving the DOM in the tests.

However, this approach needs a bit of knowledge on how to test custom hooks which I will attempt to provide the fundamentals of here.

## The first test

Open the App.test.tsx file and check it out.  This is the test that was generated by create-react-app:

#### **`src/App.test.tsx` initial**

```js
import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

Since we replaced the original App.tsx file with the input, this test should be failing now, which is fine.  Let's move on.

### Step one:  write a test

To get us started testing a custom hooks, let's test the default value, which should be empty.  Usually you would create a new test for useAnagrams, but since we have replaced the App.tsx to use the hook, we will just use this App test file for now.

#### **`src/useAnagrams.ts` step 1**

```tsx
import { renderHook } from "@testing-library/react";
import { useAnagrams } from "./useAnagrams";

describe("useAnagrams hook", () => {
  it("checking default state", () => {
    const { result } = renderHook(() => useAnagrams(""));
    expect(result.current.values().next().value).toBe("");
  });
});
```

This is actually a passing test, but I am showing it to demonstrate a basic custom hook test.

Now we will write a test for the kind of result that you are expecting.  If you think about the specification for the program we want to write, you can get an idea of what will prove that it is working.  Let's read the goal again:

*Write a program to generate all potential anagrams of an input string.*

So we will have a function that accepts the input string and output *all potential anagrams*.  That is all the combinations of the letters of the input.  This will be printed out on web page, which means it will be in the html.

#### "Don't boil the ocean when writing a test."

You might be tempted to test for the word "biro" which is shown in the instructions.  But a dev named Tony said during the first React dojo session "don't boil the ocean".   Instead of trying to test for a long array of anagrams (by typing in or pasting and formatting 24 strings), we can just use the smallest possible problem set, like 'ab' instead.

#### The UI DOM testing approach

I we were testing the output in the UI, we would have to fire the submit button being pressed action, and look for the output:

```jsx
test('should display anagrams of given input', () => {
  render(<App />);
  const nameInput = screen.getByLabelText(/Enter text/i);
  fireEvent.change(nameInput, {target: {value: "ab"}});
  fireEvent.click(screen.getByText(/submit/i));  
  const expectedAnagrams = [
    'ab', 'ba'
  ];
  expectedAnagrams.forEach((anagram) => {
    expect(document.body.innerHTML).toMatch(anagram);
  })
```

If you run the tests (or look at the tests that are already running), you will see something like this:

```bash
 FAIL  src/App.test.tsx
  × should display anagrams of given input (46ms)
  ● should display anagrams of given input
    expect(received).toMatch(expected)
    Expected substring: "ba"
    Received string:    "<div><div class=\"App\"><label for=\"name\" class=\"item padding\">Enter text</label><input id=\"name\" type=\"text\" class=\"padding\"><button class=\"padding\">Submit</button><p class=\"item\">ab</p></div></div>"
      12 |   ];
      13 |   expectedAnagrams.forEach((anagram) => {
    > 14 |     expect(document.body.innerHTML).toMatch(anagram);
         |                                     ^
      15 |   });
      16 | });
      17 |
      at forEach (src/App.test.tsx:14:37)
          at Array.forEach (<anonymous>)
      at Object.<anonymous> (src/App.test.tsx:13:20)
Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        3.46s
Ran all test suites.
```

So you can see in the output there that our <p> tag doesn't have the expected output:

```html
<p class=\"item\">ab</p></div>
```

This approach is OK, but I feel like testing the DOM adds complexity that takes away from implemeting business logic.  Sometimes the component that you need to test is complicated and you get test failures not because the hook is broken, but because the interface is complicated.  For this reason, I have changed the approach first used in this article to create a custom hook to isolate the business logic and test that custom hook directly without the UI to get in the way.

#### Using the custom hooks approach

Using the custom hook approach to isolate the anagram logic is a bit different.  Modify the above test example to something like this:

#### **`src/App.test.tsx` pt 2**

```tsx
import { renderHook, act } from "@testing-library/react";
import { useAnagrams } from "./useAnagrams";

describe("useAnagrams hook", () => {
   it("checking state updates", () => {
     const { result } = renderHook(() => useAnagrams(""));
     const [ anagram, updateAnagram ] = result.current;
     expect(result.current.values().next().value).toBe("");
     act(() => {
       updateAnagram("ab");
     });
     expect(result.current.values().next().value).toBe("ab ba");
   });
});
```

This now uses the act function to make the test run closer to how React works in the browser.

The output from the failing test should look something like this:

```shell
  ● useAnagrams hook › checking state updates
    expect(received).toBe(expected) // Object.is equality
    Expected: "ab ba"
    Received: "ab"
      10 |        updateAnagram("ab");
      11 |      });
    > 12 |      expect(result.current.values().next().value).toBe("ab ba");
         |                                                   ^
      13 |    });
      14 | });
      15 |
      at Object.<anonymous> (src/App.test.tsx:12:51)
```

[This repo has the above steps implemented on the anagrams-custom-hook branch](https://github.com/timofeysie/react-tdd-dojo/tree/anagrams-custom-hook) as a starting point for this custom hooks approach.

Now we have confirmed that the test is looking for something we want.  Time to move on to the next step.

### Step two: make is pass

The simplest way to make the test pass that we're going to do may sound like cheating, but it's not.  Just by returning the expected array checks that the test is actually working properly.  After this you can move on to the refactor step.  Lets implement the simplest function we can to make our test pass.

In the App.tsx file, right after we declare the ```const [input, setOutput] = React.useState("");```, add this function:

#### **`src/useAnagrams.ts` step 2**

```ts
setState('ab ba');
```

Now the test will pass and you will probably feel like you are cheating, but you are actually confirming that your test is doing what it should be doing.  If you actually implement the anagram code now, this test will still pass.

You could also to do a Google search for a JavaScript anagram generator, and just paste that in to make the test pass in an actual working way.  That's also valid.  I think however there is value to "testing the test".  We might somehow get the test to pass when it should be failing by using code we don't understand, and that would be bad.

However, since it's time for the next step, we could try something like that when refactoring the solution.

### Step three: refactor

Here is a basic function that will do a more realistic job for us.  Change the anagrams function to look like this:

#### **`src/useAnagrams.ts` step 3**

```js
  const anagrams = (input: string): string => {
    const newVal = input.split("")
      .map((character: string, index: number) => {
        const head = word.slice(0, index);
        const tail = word.substring(index + 1);
        const result: string[] = [];
        for (let nextCharInTail of head) {
          result.push(character + nextCharInTail);
        }
        for (let nextCharInTail of tail) {
          result.push(character + nextCharInTail);
        }
        return result;
      })
      .join(" ");
  };
  setState(newVal)
```

Now if you run the tests, it passes!  But does the app do what we want it to do yet?  Run the app with the command ```npm start``` and test it out.

If you enter "ab", you will see the expected results there returned by the function above.  But if you enter the text from the instructions, "biro" you will see this output:

```txt
bi,br,bo ib,ir,io rb,ri,ro ob,oi,or
```

So, yeah, we have a problem.  But never fear, TDD is here!  What do we do?  Back to step 1.  We write a failing test.  Let's do that now.

### Step one again

Open the test file and create a new test for what we want to see.  Now it's time to make a meaningful test.

```js
  it("checking state updates for four letter inputs", () => {
    const { result } = renderHook(() => useAnagrams(""));
    const [anagram, updateAnagram] = result.current;
    expect(result.current.values().next().value).toBe("");
    const expectedAnagrams = [
    "biro", "bior", "brio", "broi", "boir", "bori",
    "ibro", "ibor", "irbo", "irob", "iobr", "iorb",
    "rbio", "rboi", "ribo", "riob", "roib", "robi",
    "obir", "obri", "oibr", "oirb", "orbi", "orib",
  ];
    act(() => {
      updateAnagram("biro");
    });
    expect(result.current.values().next().value).toBe(expectedAnagrams);
  });
```

Yes, someone had to go through all the variations of biro to make that expected anagrams array.  Sometimes that's what you have to do.  I wouldn't want to do that for longer words, but it all depends on the kind of function you're writing.

You can see the above step in the anagrams-custom-hook-meaningful-test branch of the [Github repo](https://github.com/timofeysie/react-tdd-dojo) from above.

This test will fail in the same way our manual test of the function failed.  The output will say something like this:

```shell
  ● useAnagrams hook › checking state updates for four letter inputs
    expect(received).toBe(expected) // Object.is equality
    Expected: ["biro", "bior", "brio", "broi", "boir", "bori", "ibro", "ibor", "irbo", "irob", "iobr", "iorb", "rbio", "rboi", "ribo", "riob", "roib", "robi", "obir", "obri", "oibr", "oirb", "orbi", "orib"]
    Received: "bi,br,bo ib,ir,io rb,ri,ro ob,oi,or"
```

As you can see, our anagrams implementation is only handling two letters correctly.  Time to refactor that to make the test green again.

I wont go into an actual real life solution here.  I'm sure you could find a better function than the one we used above.  Or you could take the challenge and fix the function yourself.  If you do, use the hashtag #TDDReactAnagram and the link below on Twitter to let me know how it goes!

## Summary

It's fun to do pair programming or "mobbing" with larger groups online to solve something like this.  

TDD is a big field with many opinions.  Red-green-refactor provides a great framework which puts this powerful technique to good use.  Other benefits include learning to express your ideas about coding and testing better.

I have various branches on [this repo](https://github.com/timofeysie/react-tdd-dojo) which explore the anagrams challenge.  Have a look at some of the branches that start with the word anagrams, and make a merge request if you have a solution you think is better that one of those.

Use the hashtag #TDDReactAnagram and the link below on Twitter for any comments or feedback.

## A ChatGPT version

As an extra exercise for this challenge I asked ChatGPT to solve this problem: "Please create a javascript function that creates all anagrams for input text."

```js
function generateAnagrams(str) {
  if (str.length === 1) {
    return [str];
  }

  const anagrams = [];
  for (let i = 0; i < str.length; i++) {
    const char = str[i];
    const remainingChars = str.slice(0, i) + str.slice(i + 1);
    const subAnagrams = generateAnagrams(remainingChars);
    subAnagrams.forEach(sub => {
      anagrams.push(char + sub);
    });
  }
  return anagrams;
}
```

*This function uses recursion to generate all the possible anagrams of the input string. It works by taking a string and then iterating over each character in the string, removing it from the string, and generating all the anagrams of the remaining string. It then appends the removed character to the beginning of each anagram and adds it to the anagrams array. When the length of the input string is 1, the function returns the string as an array, since there is only 1 anagram of a string with 1 character.*

*Here is an example of how you can use this function:*

```js
const anagrams = generateAnagrams('abc');
console.log(anagrams); // [ 'abc', 'acb', 'bac', 'bca', 'cab', 'cba' ]
```

I realized that in the context of a custom hook, a recursive function is not straight forward to implement, as the setState(newVal) will erase the work each time.  I was about to fix that but then decided to let ChatGPT fix it and make the code for this specific situation.

I asked [ChatGPT](https://chat.openai.com/chat) this: "Please create a React custom hook in Typescript that creates all anagrams for input text."

This is it's response.

```js
import { useState, useEffect } from "react";

function useAnagrams(input: string) {
  const [anagrams, setAnagrams] = useState<string[]>([]);

  useEffect(() => {
    // Function to generate all anagrams for a given string
    function generateAnagrams(str: string, anagram = "", visited = {}) {
      // If the anagram is complete, add it to the list of anagrams
      if (str.length === 0) {
        setAnagrams((prevAnagrams) => [...prevAnagrams, anagram]);
        return;
      }

      // Iterate through each character in the string
      for (let i = 0; i < str.length; i++) {
        // Skip characters that have already been used in the anagram
        if (visited[i]) continue;

        // Create a new visited object for this recursive call
        // We use the spread operator to create a new object, rather than modifying the old one
        const newVisited = { ...visited };
        newVisited[i] = true;

        // Recursively call the function with the character added to the anagram, and the new visited object
        generateAnagrams(
          str.substring(0, i) + str.substring(i + 1),
          anagram + str[i],
          newVisited
        );
      }
    }

    // Reset the anagrams array and generate new anagrams
    setAnagrams([]);
    generateAnagrams(input);
  }, [input]); // Only re-run the effect if the input changes

  return anagrams;
}

export default useAnagrams;
```

This time, the comments are all inline instead of in a commentary.  Also, the formatting was missing for the start and end of the file.  It only recognized the for loop as code.  This might just be a formatting issue of the frontend site.

Two other issues with the code are shown in the VSCode editor:

```js
if (visited[i]) continue;
```

```err
Element implicitly has an 'any' type because expression of type 'number' can't be used to index type '{}'.
  No index signature with a parameter of type 'number' was found on type '{}'.ts(7053)
```

The quick and dirty solution here is to cast the type of visited to any.  I think possibly ChatGPT is using an older version of TypeScript.

Using ChatGPT as a kind of assistant tool makes sense.  In this case it has validated the use of a recursive solution to this problem.  It's answers provide a good general approach and explains the rationale for it.  A seasoned developer can the appraise the code and make adjustments needed.  Knowing your syntax becomes more important, not less, as model wont know your exact usage context unless you know how to acutely explain it.

Then how to pose the best question becomes the key, and things like the best way to specify a version of a particular lib to the ML model are important as they are in a Google search.  I can see why Google is concerned about this eating into their search business.

It's similar to a StackOverflow answer.  It would be better to solve the problem yourself in order to understand it.  Reading a tutorial with code samples allows the reader to cut and past of breeze past the learning part and fail to internalize the material.  Google, StackOverflow and now ChatGPT are tools but cannot do the job by themselves.

In this context, unit testing solutions that a developer may not fully understand becomes even more urgent.  I suppose ChatGPT can also help create the tests.

To see what kind of test ChatGPT would make, I started over again from the start since the ChatGPT frontend can continue in a conversational way to expand upon what it has done.  The solution and comments changed somewhat but are basically the same as the TypeScript version above.  Here is that session.

Me: Please create a TypeScript function that creates all anagrams for input text.

ChatGPT: *Certainly! Here is a function that takes a string as input and returns an array of all the anagrams of that string:*

```js
function getAnagrams(text: string): string[] {
  // base case: if the text is empty, there are no anagrams
  if (text.length === 0) {
    return [];
  }

  // base case: if the text has only one character, there is only one anagram
  if (text.length === 1) {
    return [text];
  }

  // initialize an empty array to store the anagrams
  const anagrams: string[] = [];

  // loop through each character in the text
  for (let i = 0; i < text.length; i++) {
    // get the current character and the remaining characters
    const char = text[i];
    const remainingChars = text.slice(0, i) + text.slice(i + 1);

    // get the anagrams of the remaining characters
    const subAnagrams = getAnagrams(remainingChars);

    // add the current character to the beginning of each anagram of the remaining characters
    subAnagrams.forEach((subAnagram) => {
      anagrams.push(char + subAnagram);
    });
  }

  return anagrams;
}
```

*This function uses recursion to generate all the anagrams of the input text. It works by looping through each character in the text, getting the anagrams of the remaining characters, and adding the current character to the beginning of each of those anagrams.*

*I hope this helps! Let me know if you have any questions or if you need further clarification.*

Me: Can you please create a meaningful unit test using Jest and the React testing-library for your anagrams function.

ChatGPT: *Certainly! Here is a unit test using Jest and the React testing-library for the getAnagrams function:*

```js
import { getAnagrams } from './anagrams';

test('getAnagrams returns correct anagrams for input text', () => {
  const anagrams = getAnagrams('abc');
  expect(anagrams).toEqual(['abc', 'acb', 'bac', 'bca', 'cab', 'cba']);
});
```

*This test checks that the getAnagrams function returns the correct array of anagrams for the input text 'abc'.*

*To test this function using the React testing-library, you would need to first render a component that calls the getAnagrams function and displays the result, and then use the testing-library's functions to interact with the rendered component and make assertions about its state.*

*Here is an example of how you might do this:*

```js
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders anagrams for input text', () => {
  render(<App />);

  const input = screen.getByLabelText('input');
  const button = screen.getByText('Generate Anagrams');

  // enter 'abc' into the input field and click the button
  fireEvent.change(input, { target: { value: 'abc' } });
  fireEvent.click(button);

  // check that the anagrams are displayed
  const anagrams = screen.getAllByText(/abc|acb|bac|bca|cab|cba/);
  expect(anagrams).toHaveLength(6);
});
```

*This test renders the App component, enters 'abc' into the input field, clicks the 'Generate Anagrams' button, and checks that the anagrams are displayed.*

*I hope this helps! Let me know if you have any questions or if you need further clarification.*

So that validates the test we made to confirm the anagrams function.

Note that ChatGPT is not the only option for developers.  Here is a good article by By Prathamesh Ingle titled [Top Artificial Intelligence (AI) Tools That Can Generate Code To Help Programmers](https://www.marktechpost.com/2023/01/01/top-artificial-intelligence-ai-tools-that-can-generate-code-to-help-programmers/ ) published yesterday on January 1st, 2023.

I probably need to write a new article now playing the Red Green Refactor game with various tools and find the out the best practices for integrating these new tools into a developers workflow.  I will update this article after that to provide the link here!
